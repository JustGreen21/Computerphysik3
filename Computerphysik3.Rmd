---
title: 'Übung 03: Pandemieausbruch'
author: "Tobias Blesgen und Leonardo Thome"
date: "09.06.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
 - \usepackage[ngerman]{babel}
 - \bibliographystyle{unsrtnat}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Im Folgenden wollen wir ein Simulierte Pandemieausbreitung von SARS-CoV-2 für verschiedene Parameter im SIR Modell betrachten.
Das SIR  Modell beschreibt den zeitlichen Verlauf mit folgendem Differentialgleichungssystem.
\begin{equation}
      S'(t) = -\frac{\beta}{N}S(t)I(t) -\Gamma(t)+ \delta V(t)
\end{equation}

\begin{equation}
      I'(t) = \frac{\beta}{N}S(t)I(t) -\alpha I(t)
\end{equation}

\begin{equation}
      R'(t) = \alpha I(t)
\end{equation}

\begin{equation}
      V'(t) = \Gamma(t) - \delta V(t)
\end{equation}

```{Rcpp}
#include<Rcpp.h>
#include<stdlib.h>
#include<stdio.h>
#include <vector>

using namespace Rcpp;

typedef struct
{
    double S, I, R, V;
} Status;

typedef struct
{
    double alpha, beta, delta, N, gamma;
} Parameter;

template<typename T>
std::vector<T> slice(std::vector<T> const &v, int m, int n)
{
    auto first = v.cbegin() + m;
    auto last = v.cbegin() + n + 1;
 
    std::vector<T> vec(first, last);
    return vec;
}

void f(Status alterStatus, Parameter parameter, Status& neuerStatus){
  double Gamma = parametergamma;
    neuerStatus.V = Gamma - parameter.delta * alterStatus.V;
    neuerStatus.R = parameter.alpha * alterStatus.I;
    neuerStatus.I = parameter.beta * alterStatus.S * alterStatus.I/parameter.N
      - parameter.alpha * alterStatus.I;
    neuerStatus.S = -parameter.beta * alterStatus.S * alterStatus.I/parameter.N
      - Gamma + parameter.delta * alterStatus.V;
}

void rkSchritt(Status& status, Parameter parameter, double h){
    Status fStatus;
    f(status, parameter, fStatus);
    Status f2Status;
    Status gemischt = {.S = status.S + h*fStatus.S, .I = status.I
      + h*fStatus.I, .R = status.R + h*fStatus.R, .V = status.V + h*fStatus.V};
    f(gemischt, parameter, f2Status);
    status.V = status.V + h/2*(fStatus.V + f2Status.V);
    status.R = status.R + h/2*(fStatus.R + f2Status.R);
    status.S = status.S + h/2*(fStatus.S + f2Status.S);
    status.I = status.I + h/2*(fStatus.I + f2Status.I);
}

//[[Rcpp::export]]
Rcpp::List durchlauf(const int maxSchritte, const double h,
                            const double S, const double I, const double R,
                            const double V, const double alpha,
                            const double beta, const double delta,
                            const double N, const double gamma){
  // Array der Werte:
    std::vector<double> xValue(maxSchritte);
    std::vector<double> SValue(maxSchritte);
    std::vector<double> IValue(maxSchritte);
    std::vector<double> RValue(maxSchritte);
    std::vector<double> VValue(maxSchritte);
  // Quelltext
  Status status = {.S = S, .I = I, .R = R, .V = V};
  Parameter parameter = {.alpha = alpha, .beta = beta, .delta = delta, .N = N, .gamma = gamma};
  
    for (int i = 0; i < maxSchritte; i++){
      xValue[i] = i*h;
      SValue[i] = status.S;
      IValue[i] = status.I;
      RValue[i] = status.R;
      VValue[i] = status.V;
      rkSchritt(status, parameter, h);
      
      if(status.I < 1 && i>10){
          // Rückgabe für eine grafische Wiedergabe
          return List::create(Named("x") = slice(xValue,0,i), 
                              Named("S") = slice(SValue,0,i), 
                              Named("I") = slice(IValue,0,i),
                              Named("R") = slice(RValue,0,i), 
                              Named("V") = slice(VValue,0,i));
      }
    }
  // Rückgabe für eine grafische Wiedergabe
    return List::create(Named("x") = xValue, Named("S") = SValue, Named("I") = IValue, Named("R") = RValue, Named("V") = VValue);
}
```

```{r, echo=FALSE}
N = 8.3e7
S = N - 5000
I = 5000
R = 0
V = 0
R0 = 2.9
alpha = 1/7
beta = R0 * alpha
delta = 0
gamma = 0
h = 1
schritte = 1000
schutzlos1 = durchlauf(schritte, h, S, I, R, V, alpha, beta, delta, N, gamma)
```

```{r, echo=FALSE}
plot(schutzlos1$x, schutzlos1$S, "l", xlab = "Tage", ylim=c(0, schutzlos1$S[1]),ylab = "Menschen", col = "dark blue")
lines(schutzlos1$x, schutzlos1$I, "l", col = "dark green")
lines(schutzlos1$x, schutzlos1$R, "l", col = "red")
legend(150,6e7,legend=c("S", "I","R"), col = c("dark blue", "green","red"), lty=1:1)
```

Betrachten wir nun die Kurven für $R_0 \in [1,20]$.

```{r, echo=FALSE}

pal <- colorRamp(c("red", "blue"))

N = 8.3e7
S = N - 5000
I = 5000
R = 0
V = 0
R0 = 15
alpha = 1/7
beta = R0 * alpha
delta = 0
gamma = 0
h = 1
schritte = 1000

schutzlos = durchlauf(schritte, h, S, I, R, V, alpha, beta, delta, N, gamma)
plot(schutzlos$x, schutzlos$I, "l", xlab = "Tage", ylim=c(0, 5.5e7), xlim=c(0,140), ylab = "erkrankte Menschen", col = rainbow(20)[R0])

range <- 1:20

for (R1 in range) {
  beta = R1 * alpha
  schutzlos = durchlauf(schritte, h, S, I, R, V, alpha, beta, delta, N, gamma)
  lines(schutzlos$x, schutzlos$I, "l", col = rainbow(20)[R1])
}

legend(100,5e7,legend=c("R0 = 1", "R0 = 7", "R0 = 14", "R0 = 20"), col = c(rainbow(20)[1], rainbow(20)[7], rainbow(20)[14], rainbow(20)[20]), lty=1:1)

```

